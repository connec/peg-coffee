// Generated by CoffeeScript 1.3.3
(function() {
  var Parser, _,
    __slice = [].slice;

  _ = require('underscore');

  module.exports = Parser = (function() {
    /*
      Encapsulates a result from a parse function.
    */

    var Context, Result;

    Parser.prototype.Result = Result = (function() {
      /*
          Create a new parse result with the given value.
      */

      function Result(value) {
        this.value = value;
      }

      /*
          Determines whether or not the result is empty.
      */


      Result.prototype.is_empty = function() {
        return this.value === void 0;
      };

      return Result;

    })();

    /*
      Encapsulates a parser context, providing useful helpers.
    */


    Parser.prototype.Context = Context = (function() {

      function Context() {}

      /*
          Extract the element at the given index from all elements of the given array.
      */


      Context.prototype.extract = function(array, index) {
        var element, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          element = array[_i];
          _results.push(element[index]);
        }
        return _results;
      };

      /*
          Recursively joins an array into a single string.
      */


      Context.prototype.join = function(array) {
        var member;
        if (array == null) {
          return '';
        }
        if (typeof array === 'string') {
          return array;
        }
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = array.length; _i < _len; _i++) {
            member = array[_i];
            _results.push(this.join(member));
          }
          return _results;
        }).call(this)).join('');
      };

      /*
          Proxy of _.compact.
      */


      Context.prototype.compact = function(array) {
        return _.compact(array);
      };

      /*
          Unescapes a string.
      */


      Context.prototype.unescape = function(string) {
        return string.replace(/\\(.)/, '$1');
      };

      return Context;

    })();

    /*
      Constructs a parser, optionally with some parse expression to mix in.
    */


    function Parser(options) {
      if (options == null) {
        options = {};
      }
      this.options = _.extend({}, options);
      this._reset();
    }

    /*
      Executes the start parsing expression on the given input and returns the result.
    */


    Parser.prototype.parse = function(input) {
      var result;
      this.input = input;
      if (!this.Start) {
        throw new Error('cannot parse without start expression');
      }
      this._reset();
      if (result = this.Start()) {
        if (this.position === this.input.length) {
          return result;
        }
      }
      return false;
    };

    /*
      Matches the given sub-expression and returns an empty result.
    */


    Parser.prototype.token = function() {
      var args, expression;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (expression.apply(this, args)) {
        return new this.Result();
      } else {
        return false;
      }
    };

    /*
      Matches the given sub-expression and, if successful, executes the given action.
    */


    Parser.prototype.action = function() {
      var action, args, expression, result, _i;
      expression = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), action = arguments[_i++];
      this.action_contexts.push({});
      if (result = expression.apply(this, args)) {
        return new this.Result(action.call(this.parse_context, _.extend(this.action_contexts.pop(), {
          $$: result.value
        })));
      } else {
        this.action_contexts.pop();
        return result;
      }
    };

    /*
      Matches the given sub-expression and stores the result as a parameter.
    */


    Parser.prototype.label = function() {
      var args, expression, name, result;
      name = arguments[0], expression = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (result = expression.apply(this, args)) {
        this._add_parameter(name, result.value);
      }
      return result;
    };

    /*
      Matches the given sub-expression without consuming any input.
    */


    Parser.prototype.check = function() {
      var args, expression, result;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      result = null;
      this._backtrack(function() {
        result = expression.apply(this, args);
        return false;
      });
      if (result) {
        return new this.Result();
      } else {
        return false;
      }
    };

    /*
      Matches the given sub-expression if it matches without consuming any input.
    */


    Parser.prototype.reject = function() {
      var args, expression;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.check.apply(this, arguments)) {
        return false;
      } else {
        return new this.Result();
      }
    };

    /*
      Matches all the given sub-expressions in order and returns an array of the results.
    */


    Parser.prototype.all = function(expressions) {
      return this._backtrack(function() {
        var args, expression, result, results, _i, _len, _ref;
        results = [];
        for (_i = 0, _len = expressions.length; _i < _len; _i++) {
          expression = expressions[_i];
          if (Array.isArray(expression)) {
            _ref = expression, expression = _ref[0], args = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
          }
          if (!(result = expression.apply(this, args))) {
            return false;
          }
          if (!result.is_empty()) {
            results.push(result.value);
          }
        }
        return new this.Result(results);
      });
    };

    /*
      Matches one of the given sub-expression and returns the result of the first successful match.
    */


    Parser.prototype.any = function(expressions) {
      var expression, result, _i, _len;
      for (_i = 0, _len = expressions.length; _i < _len; _i++) {
        expression = expressions[_i];
        if (!Array.isArray(expression)) {
          expression = [expression];
        }
        if (result = this._backtrack.apply(this, expression)) {
          return result;
        }
      }
      return false;
    };

    /*
      Matches the given sub-expression at least once and as many times as possible and returns an array
      of the results.
    */


    Parser.prototype.some = function() {
      var args, expression, result;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      result = expression.apply(this, args);
      if (result) {
        return new Result([result.value].concat(this.maybe_some.apply(this, arguments).value));
      } else {
        return false;
      }
    };

    /*
      Matches the given sub-expression as many times as possible and returns an array of the results.
    */


    Parser.prototype.maybe_some = function() {
      var args, expression, result, results;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      results = [];
      while (result = expression.apply(this, args)) {
        if (!result.is_empty()) {
          results.push(result.value);
        }
      }
      return new this.Result(results);
    };

    /*
      Attempts to match the given sub-expression, returning the sub-expression's result is so or a null
      result otherwise.
    */


    Parser.prototype.maybe = function() {
      var args, expression, result;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      result = expression.apply(this, args);
      return result || new this.Result(null);
    };

    /*
      Matches the given regular expression, returning the overall match.
    */


    Parser.prototype.regex = function(regex) {
      var match;
      if (!(match = this.input.substr(this.position).match(regex))) {
        return false;
      }
      this.position += match[0].length;
      return new this.Result(match[0]);
    };

    /*
      Matches the given literal string.
    */


    Parser.prototype.literal = function(literal) {
      if (this.input.substr(this.position, literal.length) !== literal) {
        return false;
      }
      this.position += literal.length;
      return new this.Result(literal);
    };

    /*
      Matches a single character.
    */


    Parser.prototype.advance = function() {
      if (this.input[this.position] != null) {
        return new Result(this.input[this.position++]);
      } else {
        return false;
      }
    };

    /*
      Always matches nothing.
    */


    Parser.prototype.pass = function() {
      return new Result();
    };

    /*
      Restores the parser to a 'clean' state.
    */


    Parser.prototype._reset = function() {
      this.position = 0;
      this.parse_context = new this.Context;
      this.action_contexts = [];
      return null;
    };

    /*
      Executes the given sub-expression and returns the result, and resets the position if the
      sub-expression fails.
    */


    Parser.prototype._backtrack = function() {
      var args, expression, origin, result;
      expression = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      origin = this.position;
      if (!(result = expression.apply(this, args))) {
        this.position = origin;
      }
      return result;
    };

    /*
      Adds the given parameter to the current action context.
    */


    Parser.prototype._add_parameter = function(name, result) {
      if (this.action_contexts.length === 0) {
        return;
      }
      return this.action_contexts.slice(-1)[0][name] = result;
    };

    return Parser;

  })();

}).call(this);
